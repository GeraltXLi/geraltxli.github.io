<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://geraltxli.github.io/blog</id>
    <title>GeraltXLi</title>
    <updated>2021-05-30T15:06:20.975Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://geraltxli.github.io/blog"/>
    <link rel="self" href="https://geraltxli.github.io/blog/atom.xml"/>
    <subtitle>The flash that cuts through darkness, the light that breaks the night.</subtitle>
    <logo>https://geraltxli.github.io/blog/images/avatar.png</logo>
    <icon>https://geraltxli.github.io/blog/favicon.ico</icon>
    <rights>All rights reserved 2021, GeraltXLi</rights>
    <entry>
        <title type="html"><![CDATA[Gridea扩展]]></title>
        <id>https://geraltxli.github.io/blog/post/gridea-kuo-zhan/</id>
        <link href="https://geraltxli.github.io/blog/post/gridea-kuo-zhan/">
        </link>
        <updated>2021-05-30T14:27:40.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li>代码高亮</li>
<li>搜索</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Golang-AES加密（CBC模式，PKCS7填充）]]></title>
        <id>https://geraltxli.github.io/blog/post/golang-aes-jia-mi-cbc-mo-shi-pkcs7-tian-chong/</id>
        <link href="https://geraltxli.github.io/blog/post/golang-aes-jia-mi-cbc-mo-shi-pkcs7-tian-chong/">
        </link>
        <updated>2021-05-30T13:33:56.000Z</updated>
        <summary type="html"><![CDATA[<p><a href="https://github.com/FakerGit/go-tools/tree/master/encrypt">代码地址</a></p>
<blockquote>
<p>对称加密算法，即加密和解密使用一样的密钥的加解密算法。<br>
分组密码（block cipher），是每次只能处理特定长度的一块（block）数据的一类加解密算法。<br>
目前常见的对称加密算法DES、3DES、AES都是属于分组密码。</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<p><a href="https://github.com/FakerGit/go-tools/tree/master/encrypt">代码地址</a></p>
<blockquote>
<p>对称加密算法，即加密和解密使用一样的密钥的加解密算法。<br>
分组密码（block cipher），是每次只能处理特定长度的一块（block）数据的一类加解密算法。<br>
目前常见的对称加密算法DES、3DES、AES都是属于分组密码。</p>
</blockquote>
<!-- more -->
<h3 id="背景">背景</h3>
<p>Golang没有像PHP那样提供一个现成的aes加密函数，不过标准库里有crypto，利用里面的aes等可以自己封装个加密函数，不过需要理解下整个加解密的过程和原理</p>
<!-- more -->
<hr>
<h3 id="aes加密详解">AES加密详解</h3>
<h4 id="1-参考文章golang-中aes加密详解">1. 参考文章<a href="https://blog.csdn.net/xiaohu50/article/details/51682849">golang 中AES加密详解</a></h4>
<h4 id="2-这里使用的是aes加密中的cbc模式块加密需要划分成整数长度相等个消息块不断加密串行分组长度是固定128位但密钥的长度可以使用128位192位或者256位这里指的是bit即密钥162432长度对应aes-128-aes-192-aes-256">2. 这里使用的是AES加密中的CBC模式，块加密需要划分成整数长度相等个消息块不断加密（串行），分组长度是固定128位，但密钥的长度可以使用128位，192位或者256位（这里指的是bit），即密钥16，24，32长度对应AES-128, AES-192, AES-256。</h4>
<h4 id="3初始向量要求随机但不需要保密">3.初始向量要求随机，但不需要保密。</h4>
<hr>
<h3 id="代码">代码</h3>
<p>自己研究代码比较清晰，根据<a href="https://golang.org/src/crypto/cipher/example_test.go">golang标准库AES实例代码</a>，再参考网上的PKCS7填充，最后进行base64的编码（因为加密后有些字符不可见）。最后Encrypt和Dncrypt两个就是AES加解密（CBC模式，PKCS7填充）封装后的函数，密钥位数限定16,24,32（要注意的是密钥无论多少，blocksize都是固定16）</p>
<pre><code class="language-go">package encrypt

import (
   &quot;bytes&quot;
   &quot;crypto/aes&quot;
   &quot;io&quot;
   &quot;crypto/rand&quot;
   &quot;crypto/cipher&quot;
   &quot;encoding/base64&quot;
)

/*CBC加密 按照golang标准库的例子代码
不过里面没有填充的部分,所以补上
*/

//使用PKCS7进行填充，IOS也是7
func PKCS7Padding(ciphertext []byte, blockSize int) []byte {
   padding := blockSize - len(ciphertext) % blockSize
   padtext := bytes.Repeat([]byte{byte(padding)}, padding)
   return append(ciphertext, padtext...)
}

func PKCS7UnPadding(origData []byte) []byte {
   length := len(origData)
   unpadding := int(origData[length-1])
   return origData[:(length - unpadding)]
}

//aes加密，填充秘钥key的16位，24,32分别对应AES-128, AES-192, or AES-256.
func AesCBCEncrypt(rawData,key []byte) ([]byte, error) {
   block, err := aes.NewCipher(key)
   if err != nil {
   	panic(err)
   }

   //填充原文
   blockSize := block.BlockSize()
   rawData = PKCS7Padding(rawData, blockSize)
   //初始向量IV必须是唯一，但不需要保密
   cipherText := make([]byte,blockSize+len(rawData))
   //block大小 16
   iv := cipherText[:blockSize]
   if _, err := io.ReadFull(rand.Reader,iv); err != nil {
   	panic(err)
   }

   //block大小和初始向量大小一定要一致
   mode := cipher.NewCBCEncrypter(block,iv)
   mode.CryptBlocks(cipherText[blockSize:],rawData)

   return cipherText, nil
}

func AesCBCDncrypt(encryptData, key []byte) ([]byte,error) {
   block, err := aes.NewCipher(key)
   if err != nil {
   	panic(err)
   }

   blockSize := block.BlockSize()

   if len(encryptData) &lt; blockSize {
   	panic(&quot;ciphertext too short&quot;)
   }
   iv := encryptData[:blockSize]
   encryptData = encryptData[blockSize:]

   // CBC mode always works in whole blocks.
   if len(encryptData)%blockSize != 0 {
   	panic(&quot;ciphertext is not a multiple of the block size&quot;)
   }

   mode := cipher.NewCBCDecrypter(block, iv)

   // CryptBlocks can work in-place if the two arguments are the same.
   mode.CryptBlocks(encryptData, encryptData)
   //解填充
   encryptData = PKCS7UnPadding(encryptData)
   return encryptData,nil
}


func Encrypt(rawData,key []byte) (string,error) {
   data, err:= AesCBCEncrypt(rawData,key)
   if err != nil {
   	return &quot;&quot;,err
   }
   return base64.StdEncoding.EncodeToString(data),nil
}

func Dncrypt(rawData string,key []byte) (string,error) {
   data,err := base64.StdEncoding.DecodeString(rawData)
   if err != nil {
   	return &quot;&quot;,err
   }
   dnData,err := AesCBCDncrypt(data,key)
   if err != nil {
   	return &quot;&quot;,err
   }
   return string(dnData),nil
}
</code></pre>
<pre><code class="language-json">{
    &quot;json&quot;:&quot;123&quot;,
    &quot;hah&quot;:&quot;123&quot;
}
</code></pre>
<hr>
<p><a href="https://github.com/FakerGit/go-tools">github代码地址</a></p>
<hr>
<p>参考：</p>
<ol>
<li><a href="https://blog.csdn.net/xiaohu50/article/details/51682849">golang 中AES加密详解</a></li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[一次完整的网络请求过程]]></title>
        <id>https://geraltxli.github.io/blog/post/yi-ci-wan-zheng-de-wang-luo-qing-qiu-guo-cheng/</id>
        <link href="https://geraltxli.github.io/blog/post/yi-ci-wan-zheng-de-wang-luo-qing-qiu-guo-cheng/">
        </link>
        <updated>2021-05-30T07:03:38.000Z</updated>
        <summary type="html"><![CDATA[<p>从浏览器访问某个网站时所发生的事情</p>
]]></summary>
        <content type="html"><![CDATA[<p>从浏览器访问某个网站时所发生的事情</p>
<!-- more -->
<!-- more -->
<h2 id="一-dns解析">一、 DNS解析</h2>
<ul>
<li>浏览器搜索自身缓存的DNS记录（所以才会有修改host后有时候没立刻生效的原因）</li>
<li>搜索系统的hosts文件</li>
<li>路由器也有DNS缓存</li>
<li>无则继续向ISP的DNS服务请求</li>
<li>无
<ul>
<li>非转发模式：则向根服务器请求，进行递归查询，即根DNS服务器返回定义域名服务器的IP，然后到顶级域名（如<code>.com</code>服务器查询）解析，如果无法解析就会继续提供此下一级dns服务器（如<code>qq.com</code>去解析），直到找到位置</li>
<li>转发模式：dns服务器自身请求转发给上一级</li>
</ul>
</li>
</ul>
<blockquote>
<p>从客户端到本地DNS服务器是属于递归查询，而DNS服务器之间就是的交互查询就是迭代查询。</p>
</blockquote>
<h2 id="二-tcpip-协议栈通信过程">二、TCP/IP 协议栈通信过程</h2>
<figure data-type="image" tabindex="1"><img src="https://geraltxli.github.io/blog/post-images/1622358377997.png" alt="" loading="lazy"></figure>
<h3 id="1-应用层">1. 应用层</h3>
<p>定义数据格式，并按照格式解析数据。<br>
此时是HTTP协议，header的content-type定义格式，body填数据</p>
<h3 id="2-传输层">2. 传输层</h3>
<h4 id="协议栈上">协议栈上</h4>
<p>添加了TCP首部，记录端口，确认主机上应用程序的身份，把数据包交给对应的应用程序</p>
<h4 id="tcp三次握手和四次挥手">TCP三次握手和四次挥手</h4>
<figure data-type="image" tabindex="2"><img src="https://geraltxli.github.io/blog/post-images/1622358358701.png" alt="" loading="lazy"></figure>
<blockquote>
<p>ESTABLISHED <code>əˈstabliSHt</code> 已建立成功的状态</p>
</blockquote>
<ul>
<li>为什么握手要三次？为了防止已经失效的连接请求报文段突然又传到服务端</li>
<li>为什么挥手要四次？当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端</li>
<li>为什么TIME_WAIT状态需要经过2MSL（max segment lifetime，即最大报文段生存时间，一般1分钟到4分钟)才能返回到CLOSE状态？四个报文都发送完毕，我们可以直接进入CLOSE状态了，
<ul>
<li>但是我们必须假象网络是不可靠的，有可以最后一个ACK丢失。所以TIME_WAIT状态就是用来重发可能丢失的ACK报文。</li>
<li>保证此次连接的重复数据段从网络中消失<br>
TCP分节可能由于路由器异常而“迷路”，在“迷路”期间，TCP发送端可能因确认超时而重发这个分节，“迷路”的分节在路由器恢复正常后也会被发送到最终的目的地，这个迟到的“迷路”分节到达时可能会引起问题。在关闭“前一个连接”之后，马上又建立起一个相同的IP和端口之间的“新连接”，这会导致“前一个连接”的迷路重复分组在“前一个连接”终止后到达，从而被“新连接”接收到了。<br>
为了避免以上情况，TCP/IP协议不允许处于TIME_WAIT状态的连接启动一个新的可用连接，因为TIME_WAIT状态持续2MSL，这就可以保证当成功建立一个新TCP连接的时候，来自旧连接重复分组已经在网络中消失。</li>
</ul>
</li>
</ul>
<h3 id="3-网络层">3. 网络层</h3>
<p>定义网络地址，区分网段，子网内MAC寻址，对不同子网的数据包进行路由</p>
<ul>
<li>IP协议通过子网掩码计算网络地址，判断两个主机是否属于同一个子网</li>
<li>ARP协议以太网广播给子网的所有主机，IP地址相同的话，主机会返回MAC地址，不同则丢弃。与此同时，ARP会缓存这个映射关系。此时寻址限制于同一个子网</li>
<li>路由协议，不同子网，通过本子网的网关进行路由</li>
<li></li>
</ul>
<h3 id="4-链路层">4. 链路层</h3>
<ul>
<li>对电信号进行分组并形成具有特定意义的数据帧，然后以广播的形式通过物理介质发送给接收方。以太网规定一组电信号就是一个数据包，一个数据包被称为一帧， 制定这个规则的协议就是以太网协议。</li>
<li>子网广播，主机通过MAC地址来决定是否处理数据</li>
</ul>
]]></content>
    </entry>
</feed>